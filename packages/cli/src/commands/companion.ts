import { existsSync, mkdirSync, readFileSync, unlinkSync, writeFileSync } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";

import * as p from "@clack/prompts";

import { DEFAULT_SOUL, buildUserContext, mergeUserContext } from "@grindxp/core";
import {
  createCompanionInsight,
  deleteCompanionInsight,
  getCompanionByUserId,
  listCompanionInsights,
  updateCompanionInsight,
  updateCompanionSoul,
  updateCompanionUserContext,
  upsertCompanion,
} from "@grindxp/core/vault";
import type { CliContext } from "../context";

const INSIGHT_CATEGORIES = ["pattern", "preference", "goal", "context"] as const;
type InsightCategory = (typeof INSIGHT_CATEGORIES)[number];

function getEditor(): string {
  return process.env.VISUAL ?? process.env.EDITOR ?? "vi";
}

async function openInEditor(content: string, suffix = ".md"): Promise<string | null> {
  const dir = join(tmpdir(), "grind");
  mkdirSync(dir, { recursive: true });
  const tmpFile = join(dir, `edit-${Date.now()}${suffix}`);

  writeFileSync(tmpFile, content, "utf-8");

  const editor = getEditor();
  const proc = Bun.spawn([editor, tmpFile], {
    stdio: ["inherit", "inherit", "inherit"],
  });
  await proc.exited;

  if (proc.exitCode !== 0) {
    try {
      unlinkSync(tmpFile);
    } catch {}
    return null;
  }

  const result = readFileSync(tmpFile, "utf-8");
  try {
    unlinkSync(tmpFile);
  } catch {}

  if (result === content) return null;
  return result;
}

async function requireCompanion(
  ctx: CliContext,
): Promise<NonNullable<Awaited<ReturnType<typeof getCompanionByUserId>>>> {
  const companion = await getCompanionByUserId(ctx.db, ctx.user.id);
  if (!companion) {
    p.log.error("No companion configured. Run `grindxp init` with companion enabled.");
    process.exit(1);
  }
  return companion;
}

function snippet(value: string, max = 72): string {
  const compact = value.replace(/\s+/g, " ").trim();
  if (compact.length <= max) return compact;
  return `${compact.slice(0, max - 1)}…`;
}

function formatConfidence(value: number): string {
  return `${Math.round(value * 100)}%`;
}

async function chooseInsightId(ctx: CliContext, prefix?: string): Promise<string | null> {
  const insights = await listCompanionInsights(ctx.db, ctx.user.id, 50);
  if (insights.length === 0) {
    p.log.info("No insights yet. Use `grindxp companion memory add`.");
    return null;
  }

  if (prefix) {
    const match = insights.find((insight) => insight.id.startsWith(prefix));
    if (!match) {
      p.log.error(`No insight matching "${prefix}".`);
      return null;
    }
    return match.id;
  }

  const selected = await p.select({
    message: "Select insight:",
    options: insights.map((insight) => ({
      value: insight.id,
      label: `${insight.category} ${insight.id.slice(0, 8)} ${formatConfidence(insight.confidence)}`,
      hint: snippet(insight.content),
    })),
  });

  if (p.isCancel(selected)) {
    p.cancel("Cancelled.");
    return null;
  }

  return selected as string;
}

export async function companionSoulCommand(ctx: CliContext): Promise<void> {
  const companion = await requireCompanion(ctx);

  const current = companion.systemPrompt ?? DEFAULT_SOUL;
  const updated = await openInEditor(current);

  if (updated === null) {
    p.log.info("No changes.");
    return;
  }

  const trimmed = updated.trim();
  if (!trimmed) {
    p.log.warn("Empty soul — keeping previous version.");
    return;
  }

  await updateCompanionSoul(ctx.db, ctx.user.id, trimmed);
  p.log.success("Soul updated.");
}

export async function companionContextCommand(ctx: CliContext, refresh: boolean): Promise<void> {
  const companion = await requireCompanion(ctx);

  if (refresh) {
    const autoGenerated = await buildUserContext(ctx.db, ctx.user.id);
    const merged = mergeUserContext(autoGenerated, companion.userContext);
    await updateCompanionUserContext(ctx.db, ctx.user.id, merged);
    p.log.success("Context refreshed from vault data.");
    return;
  }

  const autoGenerated = await buildUserContext(ctx.db, ctx.user.id);
  const current = companion.userContext
    ? mergeUserContext(autoGenerated, companion.userContext)
    : autoGenerated;

  const header =
    "# This is what your companion knows about you. Edit freely.\n# Everything above the --- line is auto-generated and will be refreshed.\n# Your notes below --- are preserved.\n\n";
  const updated = await openInEditor(header + current);

  if (updated === null) {
    p.log.info("No changes.");
    return;
  }

  const cleaned = updated.replace(/^#[^\n]*\n/gm, "").trim();
  if (!cleaned) {
    p.log.warn("Empty context — keeping previous version.");
    return;
  }

  await updateCompanionUserContext(ctx.db, ctx.user.id, cleaned);
  p.log.success("Context updated.");
}

export async function companionShowCommand(ctx: CliContext): Promise<void> {
  const companion = await requireCompanion(ctx);

  const soul = companion.systemPrompt ?? DEFAULT_SOUL;
  const trustNames: Record<number, string> = {
    0: "Watcher",
    1: "Advisor",
    2: "Scribe",
    3: "Agent",
    4: "Sovereign",
  };
  const trustName = trustNames[companion.trustLevel] ?? `Lv.${companion.trustLevel}`;

  const nameDisplay = companion.name
    ? `${companion.emoji ?? ""} ${companion.name}`.trim()
    : "(unnamed)";

  p.note(
    [
      `Name:     ${nameDisplay}`,
      `Mode:     ${companion.mode}`,
      `Trust:    ${trustName} (score: ${companion.trustScore})`,
      `Provider: ${companion.provider}`,
      `Model:    ${companion.model}`,
    ].join("\n"),
    "Companion",
  );

  p.note(soul, "Soul");

  if (companion.userContext) {
    p.note(companion.userContext, "User Context");
  } else {
    p.log.info("No user context set. Run `grindxp companion context` to generate one.");
  }
}

export async function companionMemoryListCommand(ctx: CliContext): Promise<void> {
  await requireCompanion(ctx);
  const insights = await listCompanionInsights(ctx.db, ctx.user.id, 100);

  if (insights.length === 0) {
    p.log.info("No insights stored yet. Use `grindxp companion memory add`.");
    return;
  }

  p.log.step(`Companion Memory (${insights.length})`);

  for (const category of INSIGHT_CATEGORIES) {
    const bucket = insights.filter((insight) => insight.category === category);
    if (bucket.length === 0) continue;

    p.log.message(`${category.toUpperCase()} (${bucket.length})`);
    for (const insight of bucket) {
      p.log.message(
        `  ${insight.id.slice(0, 8)}  ${formatConfidence(insight.confidence)}  ${insight.source}  ${snippet(insight.content, 120)}`,
      );
    }
  }
}

export async function companionMemoryAddCommand(ctx: CliContext): Promise<void> {
  await requireCompanion(ctx);

  const category = await p.select({
    message: "Insight category:",
    options: [
      { value: "pattern" as const, label: "Pattern", hint: "Behavioral trend over time" },
      { value: "preference" as const, label: "Preference", hint: "User likes/dislikes" },
      { value: "goal" as const, label: "Goal", hint: "Long-term target" },
      { value: "context" as const, label: "Context", hint: "Durable situational fact" },
    ],
  });
  if (p.isCancel(category)) {
    p.cancel("Cancelled.");
    return;
  }

  const content = await p.text({
    message: "Insight content:",
    placeholder: "e.g. User prefers short direct check-ins at night",
    validate: (value) => {
      if (!value || value.trim().length < 3) return "Please provide at least 3 characters.";
      if (value.length > 500) return "Keep it under 500 characters.";
      return undefined;
    },
  });
  if (p.isCancel(content)) {
    p.cancel("Cancelled.");
    return;
  }

  const confidenceRaw = await p.text({
    message: "Confidence (0.0 - 1.0):",
    initialValue: "0.9",
    validate: (value) => {
      const parsed = Number(value);
      if (!Number.isFinite(parsed) || parsed < 0 || parsed > 1) {
        return "Enter a number between 0 and 1.";
      }
      return undefined;
    },
  });
  if (p.isCancel(confidenceRaw)) {
    p.cancel("Cancelled.");
    return;
  }

  const source = await p.select({
    message: "Source:",
    options: [
      { value: "user-stated" as const, label: "User stated", hint: "Explicitly said by user" },
      { value: "ai-observed" as const, label: "AI observed", hint: "Inferred pattern" },
    ],
    initialValue: "user-stated",
  });
  if (p.isCancel(source)) {
    p.cancel("Cancelled.");
    return;
  }

  const created = await createCompanionInsight(ctx.db, {
    userId: ctx.user.id,
    category: category as InsightCategory,
    content: (content as string).trim(),
    confidence: Number(confidenceRaw),
    source: source as "user-stated" | "ai-observed",
    metadata: {},
  });

  p.log.success(
    `Stored insight ${created.id.slice(0, 8)} (${created.category}, ${formatConfidence(created.confidence)}).`,
  );
}

export async function companionMemoryEditCommand(
  ctx: CliContext,
  idPrefix?: string,
): Promise<void> {
  await requireCompanion(ctx);
  const insightId = await chooseInsightId(ctx, idPrefix);
  if (!insightId) return;

  const insights = await listCompanionInsights(ctx.db, ctx.user.id, 100);
  const insight = insights.find((item) => item.id === insightId);
  if (!insight) {
    p.log.error("Insight not found.");
    return;
  }

  const edited = await openInEditor(insight.content, ".md");
  if (edited === null) {
    p.log.info("No changes.");
    return;
  }

  const next = edited.trim();
  if (!next) {
    p.log.warn("Empty insight — keeping previous version.");
    return;
  }

  const updated = await updateCompanionInsight(ctx.db, insight.id, ctx.user.id, {
    content: next,
    source: "user-stated",
  });
  p.log.success(`Updated insight ${updated.id.slice(0, 8)}.`);
}

const TRUST_LEVELS: Array<{ level: number; name: string; description: string; minScore: number }> =
  [
    {
      level: 0,
      name: "Watcher",
      minScore: 0,
      description: "Read-only. Manages forge rules by risk (notifications/reminders freely).",
    },
    {
      level: 1,
      name: "Advisor",
      minScore: 10,
      description: "Can suggest quests.",
    },
    {
      level: 2,
      name: "Scribe",
      minScore: 25,
      description: "Can complete/abandon quests, start/stop timers, update companion mode.",
    },
    {
      level: 3,
      name: "Agent",
      minScore: 50,
      description: "Can create and update quests.",
    },
    {
      level: 4,
      name: "Sovereign",
      minScore: 100,
      description: "Can delete insights.",
    },
  ];

export async function companionTrustCommand(ctx: CliContext, levelArg?: string): Promise<void> {
  const companion = await requireCompanion(ctx);

  if (levelArg === undefined) {
    const currentName =
      TRUST_LEVELS.find((t) => t.level === companion.trustLevel)?.name ??
      `Lv.${companion.trustLevel}`;

    p.note(
      [
        `Current: ${currentName} (level ${companion.trustLevel}, score ${companion.trustScore})`,
        "",
        "Available levels:",
        ...TRUST_LEVELS.map((t) => {
          const marker = t.level === companion.trustLevel ? "▶" : " ";
          return `  ${marker} ${t.level} ${t.name.padEnd(10)} ${t.description}`;
        }),
        "",
        "Grant trust: grindxp companion trust <0-4>",
      ].join("\n"),
      "Companion Trust",
    );
    return;
  }

  const parsed = Number.parseInt(levelArg, 10);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 4) {
    p.log.error("Trust level must be 0–4.");
    return;
  }

  const target = TRUST_LEVELS[parsed];
  if (!target) {
    p.log.error("Invalid trust level.");
    return;
  }

  if (parsed === companion.trustLevel) {
    p.log.info(`Companion is already at ${target.name} (level ${parsed}).`);
    return;
  }

  const action = parsed > companion.trustLevel ? "Grant" : "Revoke to";
  const confirm = await p.confirm({
    message: `${action} trust level ${parsed} (${target.name})? ${target.description}`,
  });
  if (p.isCancel(confirm) || !confirm) {
    p.cancel("Cancelled.");
    return;
  }

  await upsertCompanion(ctx.db, {
    ...companion,
    trustLevel: parsed as 0 | 1 | 2 | 3 | 4,
    trustScore: Math.max(companion.trustScore, target.minScore),
  });

  p.log.success(`Trust updated to ${target.name} (level ${parsed}).`);
}

export async function companionMemoryDeleteCommand(
  ctx: CliContext,
  idPrefix?: string,
): Promise<void> {
  await requireCompanion(ctx);
  const insightId = await chooseInsightId(ctx, idPrefix);
  if (!insightId) return;

  const insights = await listCompanionInsights(ctx.db, ctx.user.id, 100);
  const insight = insights.find((item) => item.id === insightId);
  if (!insight) {
    p.log.error("Insight not found.");
    return;
  }

  p.note(
    [
      `ID: ${insight.id.slice(0, 8)}`,
      `Category: ${insight.category}`,
      `Content: ${insight.content}`,
    ].join("\n"),
    "Delete Insight",
  );

  const confirm = await p.confirm({ message: "Delete this insight?" });
  if (p.isCancel(confirm) || !confirm) {
    p.cancel("Cancelled.");
    return;
  }

  const removed = await deleteCompanionInsight(ctx.db, insight.id, ctx.user.id);
  if (!removed) {
    p.log.error("Failed to delete insight.");
    return;
  }

  p.log.success(`Deleted insight ${insight.id.slice(0, 8)}.`);
}
